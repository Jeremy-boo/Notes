
# 面试自我介绍

**面试官您好，我叫朱波，非常感谢能有机会参与今天的面试交流。**

目前是离职状态，离职之前在**闪送**担任**高级运维开发工程师**，主要负责闪送运维内部自动化以及监控项目的开发和维护工作。在此之前，我曾在**灵雀云**的DevOps团队担任后端开发工程师，参与企业级DevOps平台的架构升级与核心功能开发。以下是我在技术落地与团队协作中的主要贡献：
1. **闪送**
    - 在**闪送**主导设计和开发**统一监控平台**（Go+React), 替换掉原有搭建的 elk，n9e,以及 skywalking 等平台；
    - 研发**应用管理平台**（Go+Vue+Ansible），集成混沌测试模块，将运维任务耗时从3小时/次缩短至15分钟/次，研发自助测试覆盖率达85%；
    - 带领3人团队完成核心模块开发，推动运维效率提升300%，服务SLA从99.9%提升至99.99%。
2. **灵雀云**
    - 在**灵雀云**期间主导**CI/CD流水线重构**，从Jenkins迁移至Tekton引擎，完成Harbor插件开发与镜像分级存储方案，构建耗时降低50%（20min→10min），支撑日均10万+镜像构建；
    - 完善制品管理能力，设计镜像缓存优化、Chart构建、UI上传等模块，推动客户工具链接入成本降低40%；
    - 作为**Harbor社区贡献者**，主导ARM架构镜像仓库适配，助力公司成为Harbor官方认证服务商，贡献量国内Top6。    
以上是我的个人介绍，感谢您的时间！


# 简历当中提到的关键点

在灵雀云遇到过最有挑战的一件事情
	- ci 替换底层架构，从 jenkins 迁移到 tekton 上面
		- jenkins 流水线功能已经非常成熟了
		- 从 jenkins 切换到 tekton 需要改掉大家的日常的一个习惯
		- 带来新的知识负荷
		- 切换tkeont 整体技术架构都会涉及到重构

**Jenkins**：
优点：
1. 成熟且广泛使用：Jenkins 已经存在很长时间了，有大量的插件和社区支持。
2. 灵活性：Jenkins 提供了大量的插件，可以支持各种各样的工作流程和工具。
3. 可以在任何地方运行：Jenkins 可以在各种环境中运行，包括在本地机器上。
缺点：
4. 配置复杂：Jenkins 的配置可能会比较复杂，特别是对于大型项目或复杂的工作流程。
5. UI 不够现代：Jenkins 的用户界面可能不如一些新的 CI/CD 工具现代和用户友好。
6. 需要手动更新和维护：Jenkins 需要定期更新和维护，以保持其安全性和稳定性。

**Tekton**：
优点：
1. Kubernetes 原生：Tekton 是为 Kubernetes 设计的，因此它可以充分利用 Kubernetes 的特性，如自动扩展和自我修复。
2. 声明式配置：Tekton 使用 YAML 文件进行配置，这使得配置更加清晰和可管理。
3. 云原生和微服务友好：Tekton 
缺点：
4. 较新且不够成熟：相比 Jenkins，Tekton 是一个相对较新的项目，可能没有那么多的插件和社区支持。
5. 学习曲线较陡：由于 Tekton 是 Kubernetes 原生的，因此需要对 Kubernetes 有一定的了解才能有效使用。
6. 配置可能复杂：虽然 Tekton 使用的是声明式配置，但对于复杂的工作流程，配置可能会变得复杂和冗长。


制品管理方面：
镜像构建：
- buildkit 构建
- buildx 构建
- ko
- 以及docker build
chart 构建：
- 主要是通过使用helm+ oras 实现chart 构建oci 制品推送到远程仓库
镜像构建缓存优化：
- builtkit 支持三种模式镜像缓存 
	- registry 模式（registry 模式的缓存需要生成一层 layer 到新的镜像中，类型是 `application/vnd.buildkit.cacheconfig.v0，但是目前除了 docker hub，其他主流的 registry 都不支持：`）
	- local 模式 （local 模式的缓存，会把文件存到本地一个目录，存储过程中会生成一个 index.json.lock 文件，不支持并发写也是因为这个锁。）
	- inline 模式 （inline 模式的缓存是在目标镜像中生成对应的 cache config）


镜像构建优化：
目标： 易管理、少漏洞、镜像小、层级少、利用缓存

# 1. dockerfile 最佳实践
1. 不要安装无效软件包
2. 应简化镜像中同时运行的进程数，理想状况下，每个镜像应该只有一个进程。
3. 当无法避免同一镜像运行多进程是，应选择合理的初始化进程(init process)
4. 最小化层级数
	1. 最新的docker 只有 Run COPY ADD 创建新层，其他指令创建临时层，不增加镜像大小
	2. 多条RUN 命令可以通过连接符连接成一条指令以减少层数
	3. 通过多阶段构建减少镜像层数
5. 把多行的参数按字母排序，可以减少可能出现的重复参数，并且提高可读性
6. 编写Dockerfile 时候，应该把变更频率低的编译指令优化构建，以便放在镜像底层以有效利用 build cache
7. 复制文件时候，每个文件独立复制，这确保文件变更时候，只影响文件对应的缓存

## 针对 Harbor 方面

1. 镜像下载提速
主要是通过 Harbor 的 p2p 镜像分发，主要涉及到两个 一个是 阿里的dragfly, 第二个是 uber 的kraken

P2P镜像分发技术将需要分发的文件做分片处理，生成种子文件，每个P2P节点都根据种子文件下载分片。做分片时可以将文件拆分成多个任务并行执行，不同的节点可以从种子节点拉取不同的分片，下载完成之后自己再作为种子节点供别的节点下载。采用去中心化的拉取方式之后，流量被均匀分配到P2P网络中的节点上，可以显著提升分发速度。

2. dockerfile 中 ADD 和 copy 的区别
- add 是可以从远程URL 中获取资源，如果是压缩包可以解压缩
- copy 命令只能从宿主机复制文件到镜像中
## K8s 方面

1.对于K8S 的理解？

k8s 是一个开源的容器编排引擎，用来对容器化应用进行自动化部署、 扩缩和管理.

具有快速部署、弹性伸缩、快速扩展应用的能力.

比起docker 的优势？

自身的架构？

也可以说说劣势？
- 安装过程和配置比较复杂
- 管理服务比较繁琐

2. k8s 有哪些常见的资源
   
3. 一个pod 的创建流程
    0. 客户端将创建 Pod 的请求发送给 Apiserver
	1. Apiserver 将 Pod 信息写入 etcd,etcd 将写入结果响应给 Apiserver,Apiserver 将创建结果响应给客户端 (此时 Pod 处于 Pending 状态)
	2. Scheduler 通过 Apiserver 的 watch 接口，获取到未调度的 Pod 的通知，根据调度算法选择一个 node 节点，告诉 Apiserver 这个 Pod 应该运行在哪个节点
	3. Apiserver 将这个 Pod 和 node 的绑定信息更新到 etcd,etcd 将写入结果响应给 Apiserver
	4. Kubelet 通过 Apiserver 的 watch 接口，获取到当前节点有创建 Pod 的通知，Kubelet 调用 docker 创建容器，Kubelet 将 Pod 运行状态发送给 Apiserver
	5. Apiserver 将 Pod 状态信息更新到 etcd
   
4. 部署在k8s 里面是如何访问的？
   k8s 中的服务主要是通过service 暴露出去的，主要包括：
   - clusterip
   - nodePort
   - loadbanlance
   - exterlnalName
     
5. 怎么从集群外面访问集群里面的服务
   - 映射pod 到物理机：将Pod 端口映射到物理机上，客户端可以通过物理机的访问容器应用
   - 映射Service到物理机: 
   - 映射Service到 LoadBancer :   

6. 一个work节点如何加入k8s集群
   - node 上面安装容器运行时：可以是 docker，也可以是containered，以及kubelet 和kube-proxy
   - 配置kubelet以及kubeproxy 的启动参数，指定当前集群master节点地址
   - 通过 kubelet 的默认注册机制，将新的worker 节点加入现有集群
   - k8s master 接受了新的 work 注册之后，会自动将其纳入到当前集群的调度范围

7. helm 如何回滚和升级
   主要通过两个命令实现：
   - helm upgrade --set 指定镜像的版本
   - 回滚，通过 helm history 查看历史版本，再通过 helm rollback 其中的一个版本

8. Flannel 和 calico 之间的区别
   Flannel和Calico都是Kubernetes集群中常用的网络插件，它们用于提供容器间通信和跨节点通信的网络解决方案，但它们在实现和功能上有一些区别。下面是它们之间的主要区别：
9. Flannel：
    - Flannel是一个简单高效的容器网络解决方案，主要用于跨节点通信。
    - 它通过为每个节点创建一个虚拟网络（overlay网络），将容器的IP地址映射到该节点的虚拟网络上，从而实现跨节点的通信。
    - Flannel支持多种后端驱动，比如使用Overlay网络模型，VXLAN、Host-GW（基于主机路由）和UDP等。
    - Flannel在网络传输上的性能较好，特别适合大规模容器集群。
10. Calico：
    - Calico是一个功能强大的容器网络解决方案，主要用于容器间通信和网络安全。
    - 它使用BGP（边界网关协议）来实现容器之间的路由，每个节点上的Calico代理（Calico Node）通过BGP协议来维护容器的路由信息。
    - Calico使用Linux内核路由表来实现容器之间的直接通信，这使得其性能非常高效。
    - Calico还提供丰富的网络策略功能，允许管理员定义网络策略来限制容器之间的通信和访问。

总的来说，Flannel主要用于跨节点通信，采用简单的overlay网络，性能好且易于部署。而Calico不仅可以实现跨节点通信，还提供了丰富的网络策略功能，允许对容器之间的通信进行精细控制，适用于对网络安全有较高要求的场景。选择使用哪种网络插件取决于集群规模、网络安全需求和部署复杂度等因素。

 VXLAN和BGP是两个不同的网络技术，它们在解决不同的网络需求方面有所区别。

1. VXLAN（Virtual Extensible LAN）：
    - VXLAN是一种网络虚拟化技术，用于扩展现有的二层网络（L2网络）。
    - 它通过在底层物理网络之上创建一个虚拟网络，将多个L2域扩展到跨物理网络的广域网中。
    - VXLAN使用24位的VNI（VXLAN Network Identifier）来标识虚拟网络，从而支持大规模的隔离和多租户网络。
    - VXLAN在底层采用UDP封装数据包，将原始的L2帧封装到UDP包中，然后通过IP网络进行传输。
2. BGP（Border Gateway Protocol）：
    - BGP是一种路由协议，用于在不同自治系统（AS）之间交换路由信息。
    - 它是互联网中广泛使用的一种外部网关协议，用于实现跨越多个自治系统的IP网络的互联互通。
    - BGP根据网络的可达性和优先级决定最佳路径，使得数据包可以从源地址到达目的地址，跨越多个自治系统。

区别：
- VXLAN是一种虚拟化技术，用于在二层网络上实现扩展和隔离。它主要用于数据中心网络中的虚拟机和容器的通信，使得虚拟网络可以跨越多个物理网络。
- BGP是一种路由协议，用于实现跨越不同自治系统的互联互通。它主要用于互联网中的路由交换，确保数据包从源地址到达目的地址，跨越多个网络。

虽然它们是不同的技术，但在实际的网络架构中，有时可以结合使用。比如，Calico网络插件就使用BGP协议来实现容器之间的路由，而底层可以采用VXLAN等技术来实现跨节点的通信。这样可以充分发挥两种技术的优势，实现更灵活、高效的网络架构。


## 反问环节

- 面试这个岗位最大的挑战是什么
- 这个岗位，内部会涉及到哪些技术栈