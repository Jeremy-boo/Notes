
# 硬技能

## exmaple

**1.介绍一个你投入最多、技术难度最高、且你觉得最有价值、跟k8s 相关度最大的项目**

**How to 回答**
- 对项目的整体理解能力
- 表达能力
- 全局把控能力
- 有没有站到一个更高的视图来查看整个项目的能力
- 功能架构、技术架构

**2. Golang 和 Java 比起来最大优势是什么**

**实际在问什么**
- 对于不同语言的理解.
	- 内存分配
	- 协程的深入理解
	- 代码能力
		- 算法-leetcode
		- 控制结构
		- 数据结构
			- 数组和切片
			- map
		- 内存管理
			- 内存分配原理
			- GC 机制
		- 多线程
			- 协程
			- 锁和线程安全
			- 生产者和消费者

**3.容器跟虚拟机相比优势是什么**

1.  资源利用率：容器可以共享操作系统内核和系统资源，因此每个容器只需要占用很少的内存和磁盘空间。相比之下，虚拟机需要运行完整的操作系统，并模拟硬件资源，因此会消耗更多的内存和磁盘空间。
    
2.  启动速度：由于容器不需要启动完整的操作系统，因此它们的启动速度比虚拟机快得多。
    
3.  部署和管理：容器可以通过镜像来部署和管理，镜像包含了应用程序和其依赖项，可以轻松地在不同环境中运行。虚拟机则需要安装操作系统、软件和各种依赖项，部署和管理较为复杂。
    
4.  可移植性：由于容器可以在不同的操作系统和云平台上运行，因此具有很高的可移植性。虚拟机则需要针对不同的操作系统和云平台进行配置和调整，可移植性较差。

**实际在问什么**
- namespace/cgroup/overlayfs 等等的理解
- 操作系统
	- 内核
		- 进程调度
		- 内存管理
		- 网络协议栈
	- 容器技术
		- namespace
		- cgroup
		- overlayfs
		- 网络
	- 运维能力
		- 系统配置
		- 问题排查
		- shell脚本

**4.Label 和 Annotation的区别是什么**

**实际在问什么？**

你对K8s 对象的设计原则的理解

**5.K8s对象 resourceVersion 是怎么来的，有什么作用**

**实际问什么**

你对etcd 的理解，对k8s 对象版本控制的理解

核心架构
- k8s 架构
- 对api 对象设计原则
- 控制器工作原理
	1.  定义期望状态：用户通过 K8s API Server 提交应用程序的配置文件，包括定义应用程序所需的 Pod、Service、Deployment 等资源。
    
	1.  检测当前状态：K8s 控制器会定期查询集群中各个组件的状态，包括 Pod、Service、Deployment 等资源的状态，以及节点的健康状况等。
    
	1.  比较状态差异：K8s 控制器会将预期状态与当前状态进行比较，确定是否需要对系统进行调整，如创建、删除或更新 Pod、Service、Deployment 等资源。
    
	1.  执行调整操作：如果发现有资源的状态不符合预期状态，K8s 控制器会按照事先定义好的策略，自动执行相应的调整操作，例如创建新的 Pod、删除无效的 Pod、更新 Deployment 版本等。
    
	1.  监控状态变化：K8s 控制器会持续监控系统状态，及时检测系统中出现的异常情况，并在可能的情况下自动恢复系统状态，保证应用程序的高可用性和稳定性。

核心组件
- raft/etcd
- apiserver
	- 认证- 与企业平台的集成
	- 鉴权- 生产系统权限规划
	- 准入- 配额控制
	- 缓存- 大规模集群下的缓存配置
- kubelet
	- pod-manager  ~实际运维经验
		- cri
		- cni
		- csi
	- probe manager  ~ 问题排查能力
	- oom manager
- 调度器 ~ 是否看过代码
- 控制器 ~是否看过代码
	- deployment controller
	- statefulset controller
**- kube-proxy 代理 ~ 对内核的理解**
 
 kube-proxy 是 Kubernetes 中的一个组件，其主要作用是实现 Kubernetes Service 的负载均衡和网络代理功能。kube-proxy 实现原理如下：

1.  iptables 实现：默认情况下，kube-proxy 使用 iptables 来实现 Service 的负载均衡和网络代理功能。kube-proxy 会在每个节点上创建一个名为 kube-proxy 的 Pod，并在该 Pod 内部使用 iptables 规则来实现 Service 的负载均衡和网络代理功能。
    
2.  IPVS 实现：除了 iptables 外，kube-proxy 还可以使用 IPVS（IP Virtual Server）来实现 Service 的负载均衡和网络代理功能。使用 IPVS 可以提高 Service 的负载均衡性能和可靠性。kube-proxy 会在每个节点上创建一个名为 kube-proxy 的 Pod，并在该 Pod 内部使用 IPVS 规则来实现 Service 的负载均衡和网络代理功能。
    

无论是使用 iptables 还是 IPVS 实现，kube-proxy 在每个节点上都会监听 Kubernetes API Server 上与 Service 相关的变化，当 Service 发生变化时，kube-proxy 会相应地更新 iptables 规则或者 IPVS 规则，从而保证负载均衡和网络代理的正常运行。
	
 **- iptables 的 理解**
iptables 是 Linux 系统中用于配置和管理防火墙规则的工具。其中的五链四表是指 iptables 中的五个过滤器链和四个匹配表，分别为：

1.  输入链（INPUT）：处理目标地址与本机相同的数据包，如接收到的数据包是要访问本机的服务时。
    
2.  输出链（OUTPUT）：处理源地址与本机相同的数据包，如本机向其他主机请求服务时。
    
3.  转发链（FORWARD）：处理不是来自本机的数据包，且不是发往本机的数据包，而是在本机内部转发的数据包。
    
4.  伪装链（POSTROUTING）：对需要通过 NAT 路由后发送出去的数据包进行处理，即修改数据包的源 IP 地址或目标 IP 地址或端口等信息。
    
5.  捕获链（PREROUTING）：对需要经过 NAT 路由前的数据包进行处理，即修改数据包的目标 IP 地址或端口等信息。
    

四个匹配表分别为：

1.  连接状态匹配表（filter 表）：根据数据包的连接状态（如 NEW、ESTABLISHED、RELATED 等）进行匹配。
    
2.  ICMP 匹配表（icmp 表）：根据 ICMP 数据包类型和代码进行匹配。
    
3.  TCP/UDP 匹配表（tcp/udp 表）：根据 TCP 或 UDP 协议的端口号和数据包的标志位等信息进行匹配。
    
4.  NAT 匹配表（nat 表）：根据数据包头部的源 IP，目标 IP 和端口等信息进行匹配，并进行网络地址转换（NAT）操作。
    

总之，iptables 中的五链四表是指包含输入链、输出链、转发链、伪装链和捕获链等五个过滤器链以及连接状态匹配表、ICMP 匹配表、TCP/UDP 匹配表和 NAT 匹配表等四个匹配表，可以用来实现各种不同的防火墙规则。
 
 **ipvs 的差异**
 
 iptables 和 IPVS（IP Virtual Server）都是 Linux 内核中的网络层模块，用于实现网络数据包的转发和过滤等功能。它们之间的区别如下：

1.  功能不同：iptables 是一种基于规则的防火墙工具，可以对网络流量进行过滤、修改、重定向等操作；而 IPVS 是一种负载均衡器，可以将来自多个服务节点的流量分发到后端的多台服务器上，以达到高可用性和性能优化的目的。
    
2.  实现原理不同：iptables 是在本地主机上对数据包进行处理，使用 Netfilter 框架实现，需要在每个节点上独立配置；而 IPVS 则是在内核空间中实现的，采用 LVS（Linux Virtual Server）模块来完成负载均衡的工作，可以提供更高效的负载均衡方案。
    
3.  配置方式不同：iptables 的配置方式基于命令行或配置文件，需要手动编写规则集合；而 IPVS 的配置方式可以通过命令行或配置文件来完成，还可以与 Kubernetes、Docker 等容器编排工具进行集成。
    
4.  支持协议不同：iptables 可以支持 TCP、UDP、ICMP、IPv6 等多种协议；而 IPVS 主要支持 TCP 和 UDP 协议。
    

总之，iptables 和 IPVS 都是实现网络数据包的转发和过滤等功能的模块，在功能、实现原理、配置方式和支持协议等方面存在一定的差异。需要根据具体业务需求选择合适的工具，并进行相应的配置和管理。

**6.高可用集群如何搭建**

**实际在问什么**

你对高可用集群的理解，落实到每个组件的高可用。

持续运维
- 生产集群的运维
	- 集群搭建
	- 节点运维
- 生产系统运维
	- 日志
	- 监控
	- 告警
- CICD 流水线
	- Jenkins
	- Argocd
	- Tekton
- 应用上云
	- 容器化
	- 云原生化

**7.Istio 和 Spring Cloud 的相比较的优劣**

**实际在问什么**
深入理解Istio 的原理，优势和痛点

服务网格
- 流量管理
	- sidecar流量劫持原理
	- 智能路由
		- 灰度发布
		- 限流和熔断
		- 故障注入
	- 监控
		- 日志
		- 指标
		- 链路追踪
- 安全保证
	- ZTA
	- 认证
		- 双向TLS和点对点认证呢个
	- 授权

# 软技能

- 沟通能力
	- 能够把项目说清楚
		- 技术架构
		- 功能架构
		- 技术挑战
		- 你的价值
- 团队合作
	- 你眼里的团队价值如何体现
	- 你在团队中的角色
	- 领导力
- 学习能力和成长性
	- 对业内同类解决方案是否了解
	- 对新技术是否感兴趣
- 工作热情
	- 责任心
		- 是否能够表达清楚之前做过的项目
	- 抗压能力
		- 对于边界问题是否能快速反应并给出合理的答案

# 如何学习云原生技术

## 代码驱动
- 掌握Golang 语言编程能力

## 从点到面

- 学习容器技术
	- cgroup/namespace技术
	- 网络协议栈
	- 文件系统

## 抓住核心、掌握全局

- 深入理解k8s
	- api 定义
	- 控机制模式
	- 核心组件

## 大规模生产化

- 多集群
- 服务网格和多网格

## 必备知识点

- Docker
	- docker基本原理和操作
- K8s 基础
	- 基本原理、架构和操作
	- 声明式API
	- controller架构模式
	- CRD+Operator 机制
	- List-Watch机制(基于etcd的编程模式)
- Golang基础知识
- K8s进阶
	- CNI、CSI、CRI
	- webhooks
	- 源码解析
- 核心能力
	- 技术深度和广度的结合
		- Docker、k8s、golang基础知识扎实
	- 对技术充满热情、好奇心、保持学习
	- 结合业务场景多思考、多探索
		- 表达能力、沟通
	- 敢于实践
		- 胆大心细，不断迭代
- 面试官关注的云原生面试技术3要点
	- 计算机网络基础知识夯实
		- 计算机网络
			- TCP、UDP、HTTP/HTTPS、 Socket 编程
			- 基础数据结构
				- 线性表、栈和队列、哈希表、基本排序
			- Linux 操作系统的基础知识： 基本工具和shell 命令
	- 云原生基础知识夯实
		- Docker、K8s、Golang
	- 坦诚、踏实，良好的团队协作能力
		- 案例项目要真实，忌讳不懂装懂
		- 案例项目要清楚3W1H, 职责/贡献
		- 对于执行者，服从团队安排，并很好的完成安排的工作任务
		- 对于管理者，能很好协调内部矛盾，合理安排工作